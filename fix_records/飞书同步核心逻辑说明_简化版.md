# 飞书同步核心逻辑说明（简化版）

## 📌 核心需求
同一天多次同步今日计划到飞书时，应该**更新**已有记录，而不是**创建**新记录。

## 🔄 实现原理

### 简化流程图
```
开始同步
   ↓
查询飞书表格：是否已有今天的记录？
   ↓
   ├─ 是 → 更新这条记录
   │        ↓
   │   提示"已更新"
   │
   └─ 否 → 创建新记录
            ↓
       提示"已创建"
```

## 💡 核心代码逻辑

### 第一步：查询是否存在记录
```python
# 构建查询条件：查找日期字段 = 今天的记录
search_payload = {
    "filter": {
        "conditions": [{
            "field_name": "今天是——",  # 日期字段
            "operator": "is",
            "value": [timestamp_value]  # 今天的时间戳
        }]
    }
}

# 发送查询请求
response = requests.post(search_url, json=search_payload)
```

### 第二步：根据查询结果选择操作
```python
if existing_record_id:  # 如果找到了记录
    # 更新：使用 PUT 方法
    requests.put(update_url, json={"fields": data})
    提示 → "已更新日期 2025-10-18 的记录"
else:  # 如果没找到记录
    # 创建：使用 POST 方法
    requests.post(create_url, json={"records": [data]})
    提示 → "已创建日期 2025-10-18 的新记录"
```

## 📊 对比说明

### 修改前（总是创建）
```
第1次同步 → 创建记录1 (2025-10-18)
第2次同步 → 创建记录2 (2025-10-18)  ❌ 重复了！
第3次同步 → 创建记录3 (2025-10-18)  ❌ 又重复了！

结果：飞书表格中有3条相同日期的记录
```

### 修改后（智能判断）
```
第1次同步 → 创建记录1 (2025-10-18)  ✅ 首次创建
第2次同步 → 更新记录1 (2025-10-18)  ✅ 更新内容
第3次同步 → 更新记录1 (2025-10-18)  ✅ 再次更新

结果：飞书表格中只有1条记录，内容是最新的
```

## 🎯 关键API

### 飞书搜索API（查询记录）
```
方法: POST
地址: /records/search
作用: 查找符合条件的记录
返回: 记录ID列表
```

### 飞书更新API（更新记录）
```
方法: PUT
地址: /records/{record_id}
作用: 更新指定记录的内容
返回: 更新后的记录
```

### 飞书创建API（新建记录）
```
方法: POST
地址: /records/batch_create
作用: 批量创建新记录
返回: 创建的记录列表
```

## ✅ 优势

1. **避免重复**：同一天只有一条记录
2. **数据准确**：最新同步的内容会覆盖旧内容
3. **用户友好**：明确告知是"更新"还是"创建"
4. **向后兼容**：首次同步仍然是创建记录

## 🧪 测试方法

### 场景1：首次同步（应该创建）
1. 确保飞书表格中没有今天的记录
2. 点击"同步到飞书"
3. ✅ 看到提示："已创建日期 YYYY-MM-DD 的新记录"

### 场景2：重复同步（应该更新）
1. 修改今日计划的内容
2. 再次点击"同步到飞书"
3. ✅ 看到提示："已更新日期 YYYY-MM-DD 的记录"
4. ✅ 飞书表格中只有1条记录，内容是最新的

## 📝 总结

这次优化的核心思想：
- **查询 → 判断 → 更新或创建**
- 确保每个日期只有一条记录
- 提供清晰的操作反馈

就像编辑文档一样：
- 第一次写 → 保存（创建）
- 修改后 → 保存（更新同一个文件，而不是新建文件）
